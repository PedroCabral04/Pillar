@page "/financial/payables"
@using erp.DTOs.Financial
@using erp.Models.Financial
@using erp.Components.Shared.Dialogs.Financial
@attribute [Authorize]

<PageTitle>Contas a Pagar - Pillar ERP</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudText Typo="Typo.h4" Class="mb-4">
        <MudIcon Icon="@Icons.Material.Filled.CallMade" Class="mr-2" />
        Contas a Pagar
    </MudText>

    <MudPaper Class="pa-4 mb-4">
        <MudGrid>
            <MudItem xs="12" sm="6" md="3">
                <MudTextField @bind-Value="searchTerm" 
                             Placeholder="Buscar por fornecedor ou nota..." 
                             Adornment="Adornment.Start" 
                             AdornmentIcon="@Icons.Material.Filled.Search"
                             DebounceInterval="500"
                             OnDebounceIntervalElapsed="OnSearch" />
            </MudItem>
            <MudItem xs="12" sm="6" md="3">
                 <MudSelect T="AccountStatus?" Label="Status" Value="statusFilter" ValueChanged="OnStatusChanged" Clearable="true">
                    @foreach (AccountStatus status in Enum.GetValues(typeof(AccountStatus)))
                    {
                        <MudSelectItem Value="@((AccountStatus?)status)">@status.ToString()</MudSelectItem>
                    }
                </MudSelect>
            </MudItem>
            <MudItem xs="12" sm="6" md="3">
                <MudDateRangePicker Label="Período de Vencimento" DateRange="dateRange" DateRangeChanged="OnDateRangeChanged" Clearable="true" />
            </MudItem>
            <MudItem xs="12" sm="6" md="3" Class="d-flex align-center justify-end">
                <MudButton Variant="Variant.Filled" 
                          Color="MudBlazor.Color.Primary" 
                          StartIcon="@Icons.Material.Filled.Add"
                          OnClick="OpenCreateDialog">
                    Nova Conta
                </MudButton>
            </MudItem>
        </MudGrid>
    </MudPaper>

    <MudPaper Class="pa-4">
        <MudTable T="AccountPayableDto" ServerData="@(new Func<TableState, System.Threading.CancellationToken, Task<TableData<AccountPayableDto>>>(ServerReload))"
              @ref="table"
                  Dense="true"
                  Hover="true"
                  Striped="true">
            <HeaderContent>
                <MudTh><MudTableSortLabel SortLabel="SupplierName" T="AccountPayableDto">Fornecedor</MudTableSortLabel></MudTh>
                <MudTh>Nota Fiscal</MudTh>
                <MudTh><MudTableSortLabel SortLabel="DueDate" T="AccountPayableDto">Vencimento</MudTableSortLabel></MudTh>
                <MudTh>Valor</MudTh>
                <MudTh>Status</MudTh>
                <MudTh>Ações</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Fornecedor">@context.SupplierName</MudTd>
                <MudTd DataLabel="Nota Fiscal">@context.InvoiceNumber</MudTd>
                <MudTd DataLabel="Vencimento">@context.DueDate.ToShortDateString()</MudTd>
                <MudTd DataLabel="Valor">@context.RemainingAmount.ToString("C2")</MudTd>
                <MudTd DataLabel="Status">
                            <MudChip T="string" Size="Size.Small" Color="@GetStatusColor(context.Status)">
                        @context.StatusDescription
                    </MudChip>
                    @if (context.RequiresApproval && !context.ApprovedByUserId.HasValue)
                    {
                        <MudChip T="string" Size="Size.Small" Color="MudBlazor.Color.Warning" Icon="@Icons.Material.Filled.Warning">Aprovação Pendente</MudChip>
                    }
                </MudTd>
                <MudTd DataLabel="Ações">
                    @if (context.Status != AccountStatus.Paid && context.Status != AccountStatus.Cancelled)
                    {
                        <MudTooltip Text="Pagar">
                            <MudIconButton Icon="@Icons.Material.Filled.AttachMoney" Size="Size.Small" Color="MudBlazor.Color.Success" OnClick="@(() => OpenPayDialog(context))" Disabled="@(context.RequiresApproval && !context.ApprovedByUserId.HasValue)" />
                        </MudTooltip>
                    }
                    @if (context.RequiresApproval && !context.ApprovedByUserId.HasValue)
                    {
                         <MudTooltip Text="Aprovar">
                            <MudIconButton Icon="@Icons.Material.Filled.CheckCircle" Size="Size.Small" Color="MudBlazor.Color.Info" OnClick="@(() => ApproveAccount(context))" />
                        </MudTooltip>
                    }
                    <MudTooltip Text="Editar">
                        <MudIconButton Icon="@Icons.Material.Filled.Edit" Size="Size.Small" OnClick="@(() => OpenEditDialog(context))" Disabled="@(context.Status == AccountStatus.Paid)" />
                    </MudTooltip>
                    <MudTooltip Text="Excluir">
                        <MudIconButton Icon="@Icons.Material.Filled.Delete" Size="Size.Small" Color="MudBlazor.Color.Error" OnClick="@(() => DeleteAccount(context))" Disabled="@(context.Status == AccountStatus.Paid)" />
                    </MudTooltip>
                </MudTd>
            </RowTemplate>
            <NoRecordsContent>
                <MudText>Nenhuma conta encontrada.</MudText>
            </NoRecordsContent>
            <PagerContent>
                <MudTablePager />
            </PagerContent>
        </MudTable>
    </MudPaper>
</MudContainer>

@code {
    [Inject] private IApiService ApiService { get; set; } = null!;
    [Inject] private ISnackbar Snackbar { get; set; } = null!;
    [Inject] private IDialogService DialogService { get; set; } = null!;

    private MudTable<AccountPayableDto> table;
    private string searchTerm = "";
    private AccountStatus? statusFilter;
    private DateRange dateRange;

    private List<SupplierDto> suppliers = new();
    private List<FinancialCategoryDto> categories = new();
    private List<CostCenterDto> costCenters = new();

    protected override async Task OnInitializedAsync()
    {
        await LoadAuxiliaryData();
    }

    private async Task LoadAuxiliaryData()
    {
        try
        {
            suppliers = await ApiService.GetAsync<List<SupplierDto>>("api/suppliers") ?? new();
            categories = await ApiService.GetAsync<List<FinancialCategoryDto>>("api/financial-categories") ?? new();
            costCenters = await ApiService.GetAsync<List<CostCenterDto>>("api/cost-centers") ?? new();
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erro ao carregar dados auxiliares: {ex.Message}", Severity.Warning);
        }
    }

    private async Task<TableData<AccountPayableDto>> ServerReload(TableState state, CancellationToken cancellationToken)
    {
        try
        {
            var query = new List<string>
            {
                $"page={state.Page + 1}",
                $"pageSize={state.PageSize}",
                $"sortDescending={state.SortDirection == SortDirection.Descending}"
            };

            if (!string.IsNullOrEmpty(state.SortLabel))
            {
                query.Add($"sortBy={state.SortLabel}");
            }

            if (statusFilter.HasValue)
            {
                query.Add($"status={statusFilter.Value}");
            }

            if (dateRange?.Start.HasValue == true)
            {
                query.Add($"dueDateFrom={dateRange.Start.Value:yyyy-MM-dd}");
            }
            
            if (dateRange?.End.HasValue == true)
            {
                query.Add($"dueDateTo={dateRange.End.Value:yyyy-MM-dd}");
            }

            // Note: Search term handling might need backend support for text search if not just filtering by ID
            // For now, we assume the backend might not support generic text search on this endpoint easily without modification
            // But let's try to pass it if we can, or just rely on client side filtering if dataset is small (but this is server data)
            // The controller has supplierId filter, but not generic text search. 
            // We will skip search term for now or implement it later in backend.
            
            var queryString = string.Join("&", query);
            var response = await ApiService.GetAsync<PagedResult<AccountPayableDto>>($"api/accounts-payable?{queryString}", cancellationToken);

            if (response != null)
            {
                return new TableData<AccountPayableDto>
                {
                    TotalItems = response.TotalCount,
                    Items = response.Items
                };
            }
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Erro ao carregar contas: {ex.Message}", Severity.Error);
        }

        return new TableData<AccountPayableDto> { TotalItems = 0, Items = new List<AccountPayableDto>() };
    }

    private void OnSearch(string text)
    {
        searchTerm = text;
        table.ReloadServerData();
    }

    private void OnStatusChanged(AccountStatus? status)
    {
        statusFilter = status;
        table.ReloadServerData();
    }

    private void OnDateRangeChanged(DateRange range)
    {
        dateRange = range;
        table.ReloadServerData();
    }

    private async Task OpenCreateDialog()
    {
        var parameters = new DialogParameters();
        parameters.Add("Suppliers", suppliers);
        parameters.Add("Categories", categories);
        parameters.Add("CostCenters", costCenters);

        var options = new DialogOptions { CloseOnEscapeKey = true };
        var dialog = DialogService.Show<AccountPayableDialog>("Nova Conta a Pagar", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is CreateAccountPayableDto dto)
        {
            try
            {
                await ApiService.PostAsync<AccountPayableDto>("api/accounts-payable", dto);
                Snackbar.Add("Conta criada com sucesso", Severity.Success);
                await table.ReloadServerData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erro ao criar conta: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task OpenEditDialog(AccountPayableDto account)
    {
        var parameters = new DialogParameters();
        parameters.Add("Suppliers", suppliers);
        parameters.Add("Categories", categories);
        parameters.Add("CostCenters", costCenters);
        
        var model = new CreateAccountPayableDto
        {
            SupplierId = account.SupplierId,
            InvoiceNumber = account.InvoiceNumber,
            OriginalAmount = account.OriginalAmount,
            DiscountAmount = account.DiscountAmount,
            InterestAmount = account.InterestAmount,
            FineAmount = account.FineAmount,
            IssueDate = account.IssueDate,
            DueDate = account.DueDate,
            PaymentMethod = account.PaymentMethod,
            BankSlipNumber = account.BankSlipNumber,
            PixKey = account.PixKey,
            RequiresApproval = account.RequiresApproval,
            CategoryId = account.CategoryId,
            CostCenterId = account.CostCenterId,
            ParentAccountId = account.ParentAccountId,
            InstallmentNumber = account.InstallmentNumber,
            TotalInstallments = account.TotalInstallments,
            InvoiceAttachmentUrl = account.InvoiceAttachmentUrl,
            Notes = account.Notes,
            InternalNotes = account.InternalNotes
        };
        
        parameters.Add("Model", model);

        var options = new DialogOptions { CloseOnEscapeKey = true };
        var dialog = DialogService.Show<AccountPayableDialog>("Editar Conta a Pagar", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled && result.Data is CreateAccountPayableDto dto)
        {
            try
            {
                // We need UpdateAccountPayableDto which inherits from CreateAccountPayableDto
                // We can just serialize/deserialize or map it manually
                var updateDto = new UpdateAccountPayableDto
                {
                    SupplierId = dto.SupplierId,
                    InvoiceNumber = dto.InvoiceNumber,
                    OriginalAmount = dto.OriginalAmount,
                    DiscountAmount = dto.DiscountAmount,
                    InterestAmount = dto.InterestAmount,
                    FineAmount = dto.FineAmount,
                    IssueDate = dto.IssueDate,
                    DueDate = dto.DueDate,
                    PaymentMethod = dto.PaymentMethod,
                    BankSlipNumber = dto.BankSlipNumber,
                    PixKey = dto.PixKey,
                    RequiresApproval = dto.RequiresApproval,
                    CategoryId = dto.CategoryId,
                    CostCenterId = dto.CostCenterId,
                    ParentAccountId = dto.ParentAccountId,
                    InstallmentNumber = dto.InstallmentNumber,
                    TotalInstallments = dto.TotalInstallments,
                    InvoiceAttachmentUrl = dto.InvoiceAttachmentUrl,
                    Notes = dto.Notes,
                    InternalNotes = dto.InternalNotes,
                    Status = account.Status // Keep existing status
                };

                await ApiService.PutAsync($"api/accounts-payable/{account.Id}", updateDto);
                Snackbar.Add("Conta atualizada com sucesso", Severity.Success);
                await table.ReloadServerData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erro ao atualizar conta: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task OpenPayDialog(AccountPayableDto account)
    {
        var parameters = new DialogParameters();
        parameters.Add("PaidAmount", account.RemainingAmount);
        
        var options = new DialogOptions { MaxWidth = MaxWidth.Small, FullWidth = false };
        var dialog = DialogService.Show<PaymentDialog>("Registrar Pagamento", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            try
            {
                // The dialog returns an anonymous object or we can cast it dynamically
                // But better to use a DTO or specific class. 
                // In PaymentDialog we returned an anonymous object. 
                // Let's assume we can get the properties via reflection or dynamic
                
                dynamic data = result.Data;
                var payDto = new PayAccountPayableDto
                {
                    PaidAmount = data.PaidAmount,
                    PaymentDate = data.PaymentDate,
                    AdditionalDiscount = data.AdditionalDiscount,
                    AdditionalInterest = data.AdditionalInterest,
                    AdditionalFine = data.AdditionalFine,
                    Notes = data.Notes
                };

                await ApiService.PostAsync($"api/accounts-payable/{account.Id}/pay", payDto);
                Snackbar.Add("Pagamento registrado com sucesso", Severity.Success);
                await table.ReloadServerData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erro ao registrar pagamento: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task ApproveAccount(AccountPayableDto account)
    {
        var parameters = new DialogParameters();
        parameters.Add("ContentText", $"Confirma a aprovação da conta {account.InvoiceNumber}?");
        parameters.Add("ButtonText", "Aprovar");
        parameters.Add("Color", MudBlazor.Color.Success);

        var options = new DialogOptions() { CloseButton = true, MaxWidth = MaxWidth.ExtraSmall };
        var dialog = DialogService.Show<erp.Components.Shared.Dialogs.ConfirmDialog>("Aprovar Conta", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            try
            {
                var approveDto = new ApproveAccountPayableDto { Approved = true };
                await ApiService.PostAsync($"api/accounts-payable/{account.Id}/approve", approveDto);
                Snackbar.Add("Conta aprovada com sucesso", Severity.Success);
                await table.ReloadServerData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erro ao aprovar conta: {ex.Message}", Severity.Error);
            }
        }
    }

    private async Task DeleteAccount(AccountPayableDto account)
    {
        var parameters = new DialogParameters();
        parameters.Add("ContentText", $"Tem certeza que deseja excluir a conta {account.InvoiceNumber}?");
        parameters.Add("ButtonText", "Excluir");
        parameters.Add("Color", MudBlazor.Color.Error);

        var options = new DialogOptions() { CloseButton = true, MaxWidth = MaxWidth.ExtraSmall };
        var dialog = DialogService.Show<erp.Components.Shared.Dialogs.ConfirmDialog>("Excluir Conta", parameters, options);
        var result = await dialog.Result;

        if (!result.Canceled)
        {
            try
            {
                await ApiService.DeleteAsync($"api/accounts-payable/{account.Id}");
                Snackbar.Add("Conta excluída com sucesso", Severity.Success);
                await table.ReloadServerData();
            }
            catch (Exception ex)
            {
                Snackbar.Add($"Erro ao excluir conta: {ex.Message}", Severity.Error);
            }
        }
    }

    private MudBlazor.Color GetStatusColor(AccountStatus status)
    {
        return status switch
        {
            AccountStatus.Pending => MudBlazor.Color.Warning,
            AccountStatus.Paid => MudBlazor.Color.Success,
            AccountStatus.Overdue => MudBlazor.Color.Error,
            AccountStatus.Cancelled => MudBlazor.Color.Default,
            _ => MudBlazor.Color.Default
        };
    }

    public class PagedResult<T>
    {
        public List<T> Items { get; set; } = new();
        public int TotalCount { get; set; }
    }
}
